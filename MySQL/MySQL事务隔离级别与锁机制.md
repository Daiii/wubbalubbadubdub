[toc]

## 事务及其ACID属性

事务是由一组SQL语句组成的逻辑处理单元，事务具有4个属性，通畅简称为事务的ACID属性。

* 原子性(Atomicity)：事务是一个原子操作单元，其对数据的修改要么全部执行，要么全部不执行。
* 一致性(Consistent)：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据都必须应用于事务的修改，以保持数据的完整性。
* 隔离性(Isolation)：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的”独立“环境执行。这意味着事务处理过程中的中间状态对外部是不可见的。
* 持久性(Durable)：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

### 并发事务带来的问题

#### 更新丢失(Lost Update)或脏写

​	当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题-**最后的更新覆盖了其他事务的更新。**

#### 脏读(Dirty Reads)

​	一个事务正在对一条记录修改，在这个事务完成提交前，这条记录的数据就处于不一致的状态；这时，另一个事务也来读取一条记录，如果不加控制，第二个事务读取了这些”脏“数据，并据此做进一步处理，就会产生未提交的数据以来关系。这种现象就叫做”脏读“。

​	一句话形容：**事务A读取了事务B已经修改但尚未提交的数据**，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。

#### 不可重读(Non-Repeatable Reads)

​	一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了。这种现象叫”不可重复读“。

​	一句话形容：**事务A内部的相同查询语句在不同时刻读出的结果不一致**，不符合隔离性。

#### 幻读(Phantom Reads)

​	一个事务按相同的查询条件读取以前检索过的数据，缺发现其他事物插入了满足其查询条件的新数据，这种现象叫"换读"。

​	一句话形容：**事务A读取到了事务B所提交的新增数据**，不符合隔离性。



### 事务隔离级别

”脏读“、”不可重复读“和”幻读“其实都是数据库一致性的问题，必须由数据局提供一定的事务隔离机制来解决。

| 隔离级别                   | 脏读(Dirty Reads) | 不可重复读(Non-Repeatable Reads) | 幻读(Phantom Read) |
| -------------------------- | ----------------- | -------------------------------- | ------------------ |
| 读未提交(Read uncommitted) | 可能              | 可能                             | 可能               |
| 读已提交(Read committed)   | 不可能            | 可能                             | 可能               |
| 可重复读(Repeatable read)  | 不可能            | 不可能                           | 可能               |
| 可串行化(Serializable)     | 不可能            | 不可能                           | 不可能             |

数据库的事务隔离越严格，并发副作用越小，但复出的代价也越大，因为事务隔离实质上就是使事务在一定程度上”串行化“进行，这与”并发“是矛盾的。

同事，不同的应用读一致性和事务隔离程度的要求也是不同的，比如许多应用对”不可重复读“和”幻读“并不敏感，可能更关心数据并发访问的能力。

查看当前数据库个事务隔离级别

```sql
show variables like 'tx_isolation';
```

设置事务隔离级别

```sql
set tx_isolation = 'REPEATABLE-READ';
```

MySQL默认的事务隔离级别是可重复读，用Spring开发时，如果不设置隔离级别默认用MySQL设置的隔离级别，如果Spring设置了就用已设置的隔离级别。

## 锁

在数据库中，除了传统的计算资源(CPU、RAM、I/O等)的争用以外，数据也是一种需要用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。

### 锁分类

* 从性能上分为**乐观锁**(用版本比较来实现)和**悲观锁**
* 从数据库操作的类型分为**读锁**和**写锁**(都属于悲观锁)
  * 读锁(共享锁，S锁(**S**hared))：针对同一份数据，多个读操作可以同时进行而不会互相影响。
  * 写锁(排它锁，X锁(e**X**clusive))：当前写操作没完成前，它会阻断其他写锁和读锁。
* 从数据操作的粒度分为表锁和行锁。

#### 表锁

​	每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

* 手动增加表锁

```sql
lock table 表名称 read(write),表名称2 read(write);
```

* 查看表上加过的锁

```sql
show open tables;
```

* 删除表锁

```sql
unlock tables;
```

1. 对表的读操作(加读锁)，不会阻塞其他进程对同一表的读请求，但会阻塞对同一个表的写请求。只有当读锁释放后，才会执行其他进程的写操作。
2. 对表的写操作(加写锁)，会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作。

#### 行锁

每次执行锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。

InnoDB与MyISAM的最大不同的两点：

* InnoDB支持事务(TRANSACTION)
* InnoDB支持行级锁

1. MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁，在执行update、insert、delete操作会自动给涉及的表加写锁。
2. InnoDB在执行查询语句SELECT时，因为有mvcc机制不会加锁。但是update、insert、delete操作会加行锁。

**读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。**

#### 间隙锁(Gap Locks)

范围所包含的所有行记录(包含间隙行记录)一起行记录所在的间隙里插入或者修改的数据。

```sql
update table set name = null where id > 1 and id < 5;
```

1到5范围内的所有行都会被锁住，即使间隙中没有数据也会被锁。

锁的是区间，有跨区间的情况。

**间隙锁是在可重复度级别下才会生效**。

#### 临键锁(Next-key Locks)

Next-key Locks是行锁与间隙锁的组合。

#### 结论

**无索引行锁会升级为表锁(RR级别会升级为表锁，RC级别不会升级为表锁)**

**InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。**

​	InnoDB存储引擎犹豫实现了行及锁定，虽然在锁定机制的实现方面锁带来的性能消耗可能比表级锁定会更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定。当系统并发量高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势。

​	但是，InnoDB的行及锁定同样也是其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。

#### 行锁分析

```sql
show status like 'innodb_row_lock%';
```

* **Innodb_row_lock_current_waits**：当前正在等待锁定的数量
* **Innodb_row_lock_time**：从系统启动到现在锁定总时间长度
* **Innodb_row_lock_time_avg**：每次等待所花平均时间
* **Innodb_row_lock_time_max**：从系统启动到现在等待最长的一次所花时间
* **Innodb_row_lock_waits**：系统启动后到现在总共等待的次数

#### 锁优化

* 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁
* 合理设计索引，尽可能缩小锁的范围
* 尽可能减少索引条件范围，避免间隙锁
* 尽可能控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的SQL尽可能放在事务最后执行
* 尽可能低级别事务隔离
